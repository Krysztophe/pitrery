Introduction
============

pitrery is a set of Bash scripts to manage Point In Time Recovery
(PITR) backups for PostgreSQL. This is the user manual of pitrery
which, hopefully, will guide you in the process of setting up the
tools to perform you backups.


Point In Time Recovery
======================

This section introduces the principles of point in time recovery in
PostgreSQL.

Firstly, it is necessary to know that PostgreSQL always write data
twice.  Every transaction is written to the Write Ahead Log (or WAL)
and the corresponding file is synchronized to disk before PostgreSQL
answers to the user when it is committed.

The Write Ahead Log is divided in segments: these are files of 16MB
each, which names are hex numbers keeping them ordered.  Once
PostgreSQL has filled a number of WAL files, when a timeout occurs or
when a superuser asks it, the engine starts a checkpoint.  The
checkpoint consists of writing all the modification of the data to the
database files.  So data is first written to the WAL, then to the data
files.

The purpose of this is to permit crash recovery without losing data.
If PostgreSQL detects that the cluster was not cleanly shut down at
startup, then it enters recovery.  Recovery is applying missing
changes to the database files by reading transactions from the WAL.

Point In Time Recovery is based on those principles: since all the
data changes are always stored in the WAL, it means that we could have
PostgreSQL apply the changes they contain to the database files to let
it know about not yet applied transactions, even if the cluster
database files are in an inconsistent state.  To perform PITR backups,
we need to store the WAL files in a safe place, this is called WAL
archiving and PostgreSQL is able to execute an arbitrary command to
archive a WAL segment.  Then, we need a copy of the database files
along with the position in the WAL where recovery must start, this is
called the base backup.  Finally, the recovery phase is configurable,
allowing to stop at a user defined date and time.  The name, Point In
Time Recovery, comes from this feature of PostgreSQL.

Finally, these features of PostgreSQL are used to create standby
servers. When the WAL files are applied to another server, created
from a base base backup, as soon as they are archived, we get a
replicated server.


How pitrery works
=================

The purpose of pitrery is to manage the archiving of WAL segments and
automate the base backup along with restoring the files and preparing
the recovery to a date and time.  Those two job are independent in the
design of pitrery. This means that you can decide not to use the
archiving script to put WAL files in a safe place, which can be
interesting if you already have WAL based replication set up and you
do not want to replace you archiving script with the one provided by
pitrery.  However, the archiving script of pitrery can be used to
archive WAL files in different places, which make it possible to
integrate it in a replicated environment.

The archive_xlog script takes care of WAL archiving.  It uses a
configuration file to find where to archive WAL files.  Multiple
places, e.g. servers that be accessed using SSH in batch mode, or the
local machine can be configured, so that some WAL files can be used
for PITR and others for replication.  A second configuration file can
be used to reduce the size of the command line defined in the
configuration file of PostgreSQL.

The management of base backup is divided in four parts, each one using
a standalone script to perform an action: backup, restore, purge and
list.  These action can then be called by pitr_mgr, a wrapper around
those scripts that uses a configuration file to define the backup
options.  The purpose of pitr_mgr and its configuration file is reduce
and simplify the commands needed to perform a particular action.  If
it is well configured, then restore is possible from a simple command
with few arguments, because the pressure on the person running it can
be high at a time when end-users cannot access the database.

The storage place can be a remote server or the local machine. If is a
remote server, it must accessible using SSH in batch mode.  Using the
local machine as storage space can be useful back up on a filer, whose
file systems are mounted locally.

On the backup host, pitrery organizes backed up files in the following
way:

* A backup root directory is used to store everything

* The backups are then grouped in a directory named with a tag, or
  label. This enables to store backups for different servers in the same
  backup root directory without mixing them.

* In the label subdirectory, each backup is named after the date when it
  was started, this name is used by the restore script to find the best
 candidate when restoring.

Please note that the archived WAL files can be stored in a directory
inside the label subdirectory as long as its name does not start with
a number, to avoid confusing the restore with a non backup directory.


Installation
============

Prerequisites
-------------

pitrery is a set of Bash scripts, so bash is needed. Apart from bash,
standard tools found on any Linux server are needed: grep, sed, awk,
tar, gzip, ssh, scp...

GNU make is also needed to install from the source tarball.


Installation from the sources
-----------------------------

The latest version of pitrery is 1.2, it can be downloaded from the
Downloads link in GitHub.

First unpack the tarball:

    tar xzf pitrery-1.2.tar.gz


Then, go to the pitrery-1.2 directory and edit config.mk to fit your
system. Once done run make to replace the interpreter and paths in the
scripts:

    make


Finally, run install it, as root if needed: 

    make install


By default, the files are installed in /usr/local:

* scripts are installed in /usr/local/bin

* actions used by pitr_mgr are installed in /usr/local/lib/pitrery

* configuration samples are installed in /usr/local/etc/pitrery


WAL Archiving
=============

Every time PostgreSQL fills a WAL segment, it can run a command to
archive it.  It is an arbitrary command used as the value of the
archive_command parameter in postgresql.conf. PostgreSQL only checks
the return code of the command to know whether it worked or not.

To archive WAL files with pitrery, the archive_xlog script is used.
It takes a configuration file to specify where to copy the WAL segment
when PostgreSQL runs it through its archive_command configuration
parameter. This file is archive_nodes.conf, by default it is located
in /usr/local/etc/pitrery/archive_nodes.conf.

The archive_nodes.conf has the following format :

    TARGET_IP    TARGET_DIRECTORY   MODE


* TARGET_IP is the IP address of the host where to send files. To
  archive WAL files on the locally, use a local IP address of the
  server, e.g. 127.0.0.1

* TARGET_DIRECTORY is the path to the directory where to store WAL
  files on the target host. It must be writable.

* MODE controls the purpose of the archived file. It can be set to
  pitr or standby:

  * pitr compresses the file with gzip and allows to archive locally
    even if ALLOW_LOCAL is set to "no" in archive_xlog.conf (see
    below). Use this mode if the file is intended to be part of a
    backup.

  * standby does not compress the file and honors the ALLOW_LOCAL
    parameter. This mode allow to use the file for replication.

  * If mode is a dash (-), then MODE defaults to standby.

For example:

    # Send compressed files to 192.168.0.50:/backups/postgresql/prod/xlog
    192.168.0.50    /backups/postgresql/prod/xlog    pitr
    
    # Send files to standby host on 192.168.0.42:/pg_xlog/archives
    192.168.0.42    /pg_xlog/archives    -


archive_xlog can use a configuration file named archive_xlog.conf,
which setups defaults. By default, its location is
/usr/local/etc/pitrery/archive_xlog.conf, which can be overridden ion
the command line with -C option. The following parameters can be
configured:

* NODE_LIST is the path to archive_nodes.conf. This parameter can be
  overridden on the command line with the -n option.

* DEST is the default target directory on remote hosts. When
  TARGET_DIRECTORY in archive_nodes.conf is a dash (-), this directory
  is used on the remote host. This parameter can be overridden on the
  command line with the -d option. When TARGET_DIRECTORY is set for a
  host in archive_nodes.conf, the -n does not override it.

* ALLOW_LOCAL controls whether local copy is possible when MODE is set
  to standby in archive_nodes.conf.  The purpose of this parameter is
  make possible to use the same archive_nodes.conf on every hosts in a
  replication environment.  When set to "no", archive_xlog will not
  copy the file locally because it does not necessary when doing
  replication.  When MODE is pitr, ALLOW_LOCAL does not apply.  This
  parameter can be overridden on the command line with the -L option.

* SYSLOG can be set to "yes" to log messages to syslog, otherwise
  stderr is used for message.  SYSLOG_FACILITY and SYSLOG_IDENT can
  then by used to store messages in the log file of PostgreSQL when it
  is configured to use syslog.

If archiving is set up to a remote host, this host must be accessible
using SSH in batch mode, meaning that passphraseless access is to be
configured for the system user running PostgreSQL to the remote host.

Once archive_xlog is configured, PostgreSQL must be setup to use it by
modifying the archive_command parameter in postgresql.conf and
dependent parameters:

    # If using PostgreSQL >= 9.0, wal_level must be set to archive or hot_standby
    # Changing this requires a restart
    wal_level = archive
    
    # If using PostgreSQL >= 8.3, archiving must be enabled
    archive_mode = on
    
    # The archive command using the defaults
    archive_command = '/usr/local/bin/archive_xlog %p'
    
    # The archive command with parameters
    #archive_command = '/usr/local/bin/archive_xlog -n /path/to/archive_nodes.conf %p'


Depending on the version of PostgreSQL, restart the server if
wal_level or archive_mode were changed, otherwise reload it.


Using pitr_mgr to manage backups
================================

Configuration
-------------

Once the WAL archiving is setup and properly working, pitr_mgr can be
used to create, restore and manage base backups of the PostgreSQL
cluster. pitr_mgr command syntax is:

    pitr_mgr [options] action [action-specific options]


Each action that can be performed by pitr_migr executes the
corresponding script stored by default in
/usr/local/lib/pitrery. These scripts are standalone, they perform the
action based on the options given on the command line at execution
time.  The purpose of pitr_mgr is to wrap there scripts and provide
them with their command line options based on a configuration file.
This enables to reduce the command line size and try to avoid mistakes
at runtime.

Before using pitr_mgr to backup and manage backups for a specific
PostgreSQL cluster, a configuration file shall be created in the
configuration directory, /usr/local/etc/pitrery by default. This
configuration hold all the information necessary to manage backups for
this cluster. The default configuration file is pitr.conf, containing
all the default parameters.

To easiest way to configure pitr_mgr is to copy the default
configuration file to new name meaningful to our setup:

    cd /usr/local/etc/pitrery
    cp pitr.conf prod.conf


We will create a configuration file for the backup of our critical
production server. We edit this file to defined the specific
parameters of this PostgreSQL server.

The first parameters define how to connect to the PostgreSQL server to
backup. It is needed to run pg_start_backup() and pg_stop_backup() to
let us tell PostgreSQL a backup is being run. pitrery uses the same
variable as the tools of PostgreSQL :

* PGDATA is the path to the directory storing the cluster

* PGPSQL is the path to the psql program

* PostgreSQL access configuration: PGUSER, PGPORT, PGHOST and
  PGDATABASE are the well known variables to reach the server.

If psql is in the PATH, the variable can be commented out to use the
one found in the PATH. If other variables are defined in the
environment, they can be commented out in the file to have pitrery use
them.

The following parameters controls the different actions accessible
through pitr_mgr :

* PGOWNER is the system user with possess the files of the cluster, it
  is useful when restoring as root if the user want to restore as
  another user.

* BACKUP_IS_LOCAL tells pitrery that the backups are stored on the
  local machine. When set to "yes", the target host is no longer
  needed.

* BACKUP_DIR is the path to the directory where to store the backups

* BACKUP_LABEL is the name of the set of backups, all backups will be
  stored in a subdirectory named with this value to let the user store
  backups for different servers in the same BACKUP_DIR

* BACKUP_HOST is the IP address of the host where backups shall be
  stored

* RESTORE_COMMAND can be used to define the command run by PostgreSQL
  when it needs to retrieve a WAL file to apply it in recovery
  mode. It is useful when WAL archiving is not performed by
  pitrery. When archive_xlog is used, this parameter default to a call
  to restore_xlog and it is not necessary to set it up here unless
  archived WAL files are stored on a different host than BACKUP_HOST

* ARCHIVE_DIR when using restore_xlog to recover archived WAL files,
  this is the path where the WAL files are stored. It should be set to
  same path that was defined in archiv_nodes.conf for archiving.

* PURGE_KEEP_COUNT controls how many backups must be kept when purging
  old backups.

* PURGE_OLDER_THAN controls how many __days__ backups are kept when
  purging. If PURGE_KEEP_COUNT is set, this parameter is ignored.


Usage
-----

The help for pitr_mgr is available by running it with the -h option :

    $ pitr_mgr -h
    usage: pitr_mgr [options] action [args]
    options:
        -c file      Path to the configuration file
        -n           Show the command instead of executing it
        -h           Print help
    
    actions:
        list
        backup
        restore
        purge


If we want to backup our example production server, the name of the
configuration must given to pitr_mgr with the -c option. The name of
the configuration file, if it is not a path, is searched in the
configuration directory, any file ending with .conf is then taken, for
example :

    $ pitr_mgr -c prod action


This will use the file /usr/local/etc/pitrery/prod.conf. When adding
the -? switch after the action name, pitr_mgr outputs the help of the
action, for example :

    $ pitr_mgr backup -?
    backup_pitr performs a PITR base backup
    
    Usage:
        backup_pitr [options] [hostname]
    
    Backup options:
        -L              Perform a local backup
        -b dir          Backup directory
        -l label        Backup label, it will be suffixed with the date and time
        -D dir          Path to $PGDATA
    
    Connection options:
        -P PSQL         path to the psql command
        -h HOSTNAME     database server host or socket directory
        -p PORT         database server port number
        -U NAME         connect as specified database user
        -d DATABASE     database to use for connection
    
        -?              Print help


The -n option of pitr_mgr can be used to show the action script
command line that would be runned, but without running it. It is
useful to check if the parameters configured in a particular
configuration file are correct. For example, with the default
configuration file pitr.conf :

    $ pitr_mgr -n backup 192.168.0.50
    /usr/local/lib/pitrery/backup_pitr -b /var/lib/pgsql/backups -l pitr -D /var/lib/pgsql/data -P psql -h /tmp -p 5432 -U postgres -d postgres 192.168.0.50


Finally, every configuration parameter defined in the configuration
file can be overridden on the command line by adding the corresponding
switch after the action. For example, if the port of the PostgreSQL is
5433 :

    $ pitr_mgr -n backup -p 5433 192.168.0.50
    /usr/local/lib/pitrery/backup_pitr -b /var/lib/pgsql/backups -l pitr -D /var/lib/pgsql/data -P psql -h /tmp -p 5433 -U postgres -d postgres 192.168.0.50


Note: the BACKUP_HOST is not defined in the configuration file used
for the example, this is why the IP address was added after the
"backup" action.


Backup
------

To run a backup with pitr_mgr, either a configuration file is needed
or the options must be put on the commandline. The usage of the backup
action is:

    $ pitr_mgr backup -?
    backup_pitr performs a PITR base backup
    
    Usage:
        backup_pitr [options] [hostname]
    
    Backup options:
        -L              Perform a local backup
        -b dir          Backup directory
        -l label        Backup label, it will be suffixed with the date and time
        -D dir          Path to $PGDATA
    
    Connection options:
        -P PSQL         path to the psql command
        -h HOSTNAME     database server host or socket directory
        -p PORT         database server port number
        -U NAME         connect as specified database user
        -d DATABASE     database to use for connection
    
        -?              Print help


For example, the configuration file for our example production server
is the following:

    PGDATA="/home/postgres/postgresql-9.0.4/data"
    PGPSQL="/home/postgres/postgresql-9.0.4/bin/psql"
    PGUSER="postgres"
    PGPORT=5432
    PGHOST="/tmp"
    PGDATABASE="postgres"
    PGOWNER=$PGUSER
    BACKUP_IS_LOCAL="no"
    BACKUP_DIR="/home/postgres/backups"
    BACKUP_LABEL="prod"
    BACKUP_HOST=10.100.0.16
    RESTORE_COMMAND=
    ARCHIVE_DIR="/home/postgres/backups/prod/xlog"
    PURGE_KEEP_COUNT=2
    PURGE_OLDER_THAN=


With those options, pitr_mgr can run a backup:

    $ pitr_mgr -c prod backup
    INFO: backup directory is /home/postgres/backups/prod/2011.08.17-11.16.30
    INFO: preparing directories
    INFO: starting the backup process
    INFO: archiving PGDATA: /home/postgres/postgresql-9.0.4/data
    INFO: listing tablespaces
    INFO: archiving tablespace "t1" (/home/postgres/postgresql-9.0.4/t1)
    INFO: stopping the backup process
    NOTICE:  pg_stop_backup complete, all required WAL segments have been archived
    INFO: copying the backup history file
    INFO: copying the tablespaces list
    INFO: done


If we have a look at the contents of the /home/postgres/backups
directory on the backup host:

    /home/postgres/backups
    └── prod
        ├── 2011.08.17-11.16.30
        │   ├── backup_label
        │   ├── pgdata.tar.gz
        │   ├── tblspc
        │   │   └── t1.tar.gz
        │   └── tblspc_list
        └── xlog
            ├── 000000010000000000000036.gz
            ├── 000000010000000000000037.gz
            ├── 000000010000000000000038.gz
            ├── 000000010000000000000039.gz
            ├── 00000001000000000000003A.gz
            ├── 00000001000000000000003B.gz
            ├── 00000001000000000000003C.00000078.backup.gz
            ├── 00000001000000000000003C.gz
            └── 00000001000000000000003D.gz


The backup is stored in the prod/2011.08.17-11.16.30 diretory of
BACKUP_DIR, "prod" being the label defined by BACKUP_LABEL. The backup
directory is named with the date and time of the backup, this naming
will be used by the restore action to find the best candidate when
restoring to a specific date and time. The directory stores the backup
label file of PostgreSQL, a tarball of the PGDATA directory, tarballs
for each tablespace and the tablespace list for their path. Here we
have configured archive_xlog to store the WAL files in prod/Xlog to
have them close to the base backups.


Restore
-------

The restore action takes a backup and prepares the recovery to restore
to a particular point in time. The target date must given on the
command line using the -d option. Its format is the one expected by
PostgreSQL: Y-m-D H:M:S TZ'.

This action perform the following steps:

* Find the newer possible backup from the store

* Retrieve and extract the contents of PGDATA and the tablespaces

* Create a recovery.conf file for PostgreSQL

The restore will only work if the target destination directory (PGDATA
in the configuration file of pitr_mgr) and the directory used by
tablespaces exist, are writable and are empty. It is important to
prepare those directories before running the restore.

When specifiying a target date, it will be used in the
$PGDATA/recovery.conf file as value for the recovery_target_time
parameter.

Unless RESTORE_COMMAND is defined to something else, the restore_xlog
script will be used by PostgreSQL to retrieve archived WAL files. The
purpose of this script is to find, copy on PostgreSQL server, and
uncompress the archived WAL file asked by PostgreSQL. restore_xlog can
read the archive_xlog.conf file to get its logging options, its
behavior is controlled from its command line options, for example:

    restore_xlog -n HOST -d ARCHIVE_DIR %f %p


Let's say the target directories are ready for a restore run by the
postgres user, the restore can be started with pitr_mgr on our example
production server:

    $ pitr_mgr -c prod restore -d '2011-08-17 12:00:00'
    INFO: searching backup directory
    INFO: target date is: 2011-08-17 12:00:00
    INFO: backup directory is /home/postgres/backups/prod/2011.08.17-11.16.30
    INFO: creating /home/postgres/postgresql-9.0.4/t1
    INFO: setting permissions of /home/postgres/postgresql-9.0.4/t1
    INFO: checking if /home/postgres/postgresql-9.0.4/t1 is empty
    INFO: creating /home/postgres/postgresql-9.0.4/data
    INFO: setting permissions of /home/postgres/postgresql-9.0.4/data
    INFO: checking if /home/postgres/postgresql-9.0.4/data is empty
    INFO: extracting PGDATA to /home/postgres/postgresql-9.0.4/data
    INFO: extracting tablespace "t1" to /home/postgres/postgresql-9.0.4/t1
    INFO: preparing pg_xlog directory
    INFO: preparing recovery.conf file
    INFO: done
    INFO: please check directories and recovery.conf before starting the cluster


The restore script finds that the backup to be restored is located in
/home/postgres/backups/prod/2011.08.17-11.16.30 on our backup
server. It then extracts everything, including the tablespace named t1
and prepares the recovery.conf at the root of $PGDATA. The script tell
the user to check everything before starting the PostgreSQL cluster:
This behavior is intentionnal, it allows the user to modify parameters
of PostgreSQL or change how the recovery is configured in
recovery.conf.

When everything is fine, the PostgreSQL can be started, it will apply
the archived WAL files until the target date is reached or until all
WAL files are consumed if no target date was specified.


Listing backups
---------------

The list action allow to find the backups for a particular label on
the backup host. For example:

    $ pitr_mgr -c prod list 
    List of backups on 10.100.0.16:
    /home/postgres/backups/prod/2011.08.17-11.16.30 	TIME: 2011-08-17 11:18:10 CEST


It lists the directory of each found backup with the date and time
when it was run.

Like the other commands, the options of the list action can be display
by adding the -? option after the action:

    $ pitr_mgr list -?
    usage: list_pitr [options] [hostname]
    options:
        -L              List from local storage
        -b dir          Backup storage directory
        -l label        Label used when backup was performed
    
        -?              Print help


Removing old backups
--------------------

The purge action can remove old backups according to a policy based on
the number of backups to keep or their age in days. If the maximum
number of backups and the maximum age are set, only the number of
backups is used for the purge, it prevents the user from removing all
backups if all of them are too old. The purge script will also try to
remove unnecessary archived WAL file.

The -m on the command line or the PURGE_KEEP_COUNT in the
configuration file define the maximum number of backups to keep. The
-d on the command line or the PURGE_OLDER_THAN in the configuration
file is used to define the maximum age.

For example, we have two backups on the store and we want to keep only
one:

    $ pitr_mgr -c prod purge -m 1
    INFO: purging /home/postgres/backups/prod/2011.08.17-11.16.30
    INFO: purging WAL files older than 000000020000000000000060
    INFO: done


Listing the backups then shows only one backup:

    $ pitr_mgr -c prod list
    List of backups on 10.100.0.16:
    /home/postgres/backups/prod/2011.08.17-14.58.32 	TIME: 2011-08-17 14:58:33 CEST

